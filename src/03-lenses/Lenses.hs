{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# OPTIONS_GHC -Wno-missing-signatures #-}
{-# LANGUAGE FlexibleContexts    #-}
{-# LANGUAGE FlexibleInstances   #-}
{-# LANGUAGE RankNTypes          #-}
{-# LANGUAGE RecordWildCards     #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE TypeApplications    #-}
{-# LANGUAGE TypeFamilies        #-}

module Lenses where

-------------------------------------
import           Control.Applicative
import           Control.Lens
import           Data.Char
import qualified Data.Map            as Map
import qualified Data.Set            as Set
import qualified Data.Text           as T

-------------------------------------
-- actions: operations which can be performed on data.
-- optics: data selecors
--
-- Lenses guarantees:
--  * A Lens focuses (i.e. selects) a single piece of data within a larger structure.
--  * A Lens must never fail to get or modify that focus.
-- Actions:
--  * view the focus within a structure.
--  * set the focus within a structure.
--  * modify the focus within a structure.
-- Lens' s a (s: structure, a: focus)
--
-- type Lens' = Lens s s a a -- A tick is for the simple optic, as opposed to a polymorphic optic
--
-- _1 :: Lens' (a, b) a -- focuses first slot of a tuple
-- _1 is simplified i.e. it works for n-arity tuples.
-- There is also: _2, _3, ...
--
-- Actions:
--  * view :: Lens' s a -> s -> a
--  * set  :: Lens' s a -> a -> s -> s
--  * over :: Lens' s a -> (a -> a) -> s -> s
-- >>> view _1 ('a', 'b')
-- 'a'
-- >>> set _1 'x' ('a', 'b')
-- ('x', 'b')
-- >>> over _1 (*100) (1,2)
-- (100, 2)
data Ship =
  Ship
    { _name    :: String
    , _numCrew :: Int
    }
  deriving (Show)

-- leading underscore is compulsory in the record fields otherwise the macro won't work.
-- If you want more control over the names and fields that `makeLenses` generates with, you can provide additional rules using `makeLensesFor` and `makeLensesWith`
-- The position of makeLenses **matters**.
--   Splits the file in two different modules.
--   Usually put your makeLenses at the bottom of your data declaration, but above any use.
makeLenses ''Ship

-- lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
--
-- simplified
--
-- lens :: (s -> a) -> (s -> a -> s) -> Lens' s a
getNumCrew :: Ship -> Int
getNumCrew = _numCrew

setNumCrew :: Ship -> Int -> Ship
setNumCrew ship n = ship {_numCrew = n}

--numCrew :: Lens' Ship Int
--numCrew = lens getNumCrew setNumCrew
--name :: Lens' Ship String
--name = lens _name (\ship newName -> ship{ _name = newName })
-- view extracts the getter function from a lens:
--  * view :: Lens' s a -> (s -> a)
-- set extracts the setter from the lens:
--  * set :: Lens' s a -> a -> s -> s
purplePearl = Ship {_name = "Purple Pearl", _numCrew = 38}

-- >>> set numCrew 41 purplePearl
-- Ship {_name = "Purple Pearl", _numCrew = 41}
-- Modification = view, apply function, and setting:
--   over numCrew (+3) == set numCrew (view numCrew purplePearl + 3)
-- Automatically generating field lenses:
--   makeLenses ''Ship
--
-- >>> :t name
-- name :: forall {f :: * -> *}. Functor f =>            (String -> f String)       -> Ship -> f Ship
-- ^^^^ this is an optic         ^^^^^^ usually for lens  ^^^^^^^^^^^^^^^^^^ focus     ^^^^^^^^^ structure
-- What's exported by Lenses (prints out nice names for our lenses!)
-- >>> :browse Lenses
-- data Ship = Ship {_name :: String, _numCrew :: Int}
-- numCrew :: Lens' Ship Int
-- ...
--
--
-- -----------------------
--
--
-- Laws (invariants): the restrictions they impose let us **reason** about our code more clearly.
--  * You get what you set
--  * Setting back what you got doesn't do anything
--  * Setting twice is the same as setting once
--
--  Lenses generated by makeLenses are lawful.
--
--  Breaking Laws is ok if it's intentional.
--
-- ------------------------
--
-- Case Study: lensProduct
--   From Control.Lens.Unsound (https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Unsound.html#v:lensProduct)
--   Breaks the "You get what you set" if the focuses is not disjoint.
--   >>> let badLens :: Lens' (Int, Char) (Int, Int); badLens = lensProduct _1 _1
--   >>> view badLens (set badLens (1,2) (3,'x'))
--   (2,2)
--
-- ---------------------
--
-- Exercises - Laws
-- 6.BONUS(another tricky one): Can you write a lawful lens for the following type:
-- nb. this lens is pointless in practise.
data Builder =
  Builder
    { _context :: [String]
    , _build   :: [String] -> String
    }

getBuilder :: Builder -> String
getBuilder Builder {..} = _build _context

setBuilder :: Builder -> String -> Builder
setBuilder builder str = builder {_build = const str}

-- >>> let newBuilder = set builderLens (view builderLens stringBuilder) stringBuilder
-- >>> view builderLens newBuilder
-- "abc"
-- >>> view builderLens newBuilder{_context=["d","e"]}
-- "abc" -- Expected "de"
setBuilder2 :: Builder -> String -> Builder
setBuilder2 builder@(Builder c b) newValue =
  builder
    { _build =
        \c' ->
          if c == c'
            then newValue
            else b c'
    }

-- >>> let newBuilder = set builderLens (view builderLens stringBuilder) stringBuilder
-- >>> view builderLens newBuilder
-- "abc"
-- >>> view builderLens newBuilder{_context=["d","e"]}
-- "de"
builderLens :: Lens' Builder String
builderLens = lens getBuilder setBuilder2

stringBuilder = Builder ["a", "b", "c"] concat

----------------------------------------


-- Virtual field (computed)
data Temperature =
  Temperature
    { _location :: String
    , _celsius  :: Float
    }
  deriving (Show)

makeLenses ''Temperature

celsiusToFahrenheit :: Float -> Float
celsiusToFahrenheit c = (c * (9 / 5)) + 32

fahrenheitToCelsius :: Float -> Float
fahrenheitToCelsius f = (f - 32) * (5 / 9)

tempBerlin = Temperature "Berlin" 7.0

-- >>> celsiusToFahrenheit $ view celsius tempBerlin
-- 44.6
-- Bump the temperature by 18 Fahrenheit
-- >>> over celsius (fahrenheitToCelsius . (+18) . celsiusToFahrenheit) tempBerlin
--
-- This is error prone!
-- Write a lens for the computed field
fahrenheit :: Lens' Temperature Float
fahrenheit = lens getter setter
  where
    getter = celsiusToFahrenheit . view celsius
    setter temp f = set celsius (fahrenheitToCelsius f) temp

-- >>> view fahrenheit tempBerlin
-- >>> over fahrenheit (+18) tempBerlin

---------------------------------------------

-- Breakage-free refactoring
--
-- We gain more freedom when refactor (over field accessors alternative)
--
-- For instances, we want to change _celsius for _kelvin
--
-- Example with field accessors
updateTempReading :: Temperature -> IO Temperature
updateTempReading temp = do
  newTempInCelsius <- readTemp
  return temp {_celsius = newTempInCelsius}
  --Temperature { _location :: String
              --, _kelvin   :: Float
              --}
    --deriving (Show)

-- If we change this, now every file using _celsius fails to compile.
--data Temperature =
-- With pattern-matching it would have been even worse: compile but incorrect behaviour
updateTempReading2 :: Temperature -> IO Temperature
updateTempReading2 (Temperature l _) = do
  newTempInCelsius <- readTemp
  return (Temperature l newTempInCelsius)

readTemp :: IO Float
readTemp = return 7.0

-- Example with lenses
updateTempReading3 :: Temperature -> IO Temperature
updateTempReading3 temp = do
  newTempInCelsius <- readTemp
  return $ set celsius newTempInCelsius temp

-- The name should be the same but it clashes with my previous examples.
data Temperature2 =
  Temperature2
    { _locat  :: String
    , _kelvin :: Float
    }
  deriving (Show)

makeLenses ''Temperature2

celsius2 :: Lens' Temperature2 Float
celsius2 = lens getter setter
  where
    getter = (subtract 273.15) . view kelvin
    setter temp c = set kelvin (c + 273.15) temp

-- With the lenses approach, doing the refactor is simple and 0 boilerplate.
--
-- When adopting this style it's important to avoid exporting the data type constructor or field accessors.
-- Export a "smart constructor" function and the lenses for each field instead.
-- Exercises - Virtual Fields
data User =
  User
    { _firstName :: String
    , _lastName  :: String
       -- , _username :: String
    , _email     :: String
    }
  deriving (Show)

makeLenses ''User

-- 1. User email in place of username everywhere in your codebase
username :: Lens' User String
username = lens getter setter
  where
    getter = view email
    setter user v = set email v user

-- 2. write a lens for fullName.
fullName :: Lens' User String
fullName = lens getter setter
  where
    getter u = view firstName u ++ " " ++ view lastName u
    setter u v =
      case words v of
        newFirstName:newLastName ->
          set lastName (unwords newLastName) $ set firstName newFirstName u
        _ -> u

-- >>> let user = User "John" "Cena" "invisible@example.com"
-- >>> view fullName user
-- >>> set fullName  "Doctor of Cosmos" user

------------------------------------------

-- Data correction and maintaining invariants
--
-- Use lenses to performm certain types of data correction to ensure our data remains in a valid state.
--
--
data Time =
  Time
    { _hours :: Int
    , _mins  :: Int
    }
  deriving (Show)

-- We want the users to edit the time of the clock, so we'll expose some lenses.
-- 0 <= hours <= 23
-- 0 <= mins <= 59
clamp :: (Ord a) => a -> a -> a -> a
clamp minVal maxVal a = min maxVal . max minVal $ a

hours :: Lens' Time Int
hours = lens getter setter
  where
    getter (Time h _) = h
    setter (Time _ m) newHours = Time (clamp 0 23 newHours) m

mins :: Lens' Time Int
mins = lens getter setter
  where
    getter (Time _ m) = m
    setter (Time h _) newMinutes = Time h (clamp 0 59 newMinutes)

-- Note, these are **not** lawful lenses, but still useful.
-- An alternative
hours2 :: Lens' Time Int
hours2 = lens getter setter
  where
    getter (Time h _) = h
    setter (Time _ m) newHours = Time (newHours `mod` 24) m

mins2 :: Lens' Time Int
mins2 = lens getter setter
  where
    getter (Time _ m) = m
    setter (Time h _) newMinutes =
      Time ((h + (newMinutes `div` 60)) `mod` 24) (newMinutes `mod` 60)

-- Note, these are **not** lawful lenses, but still useful.
-- >>> let time = Time 3 10
-- >>> over mins (+ 55) time
-- >>> over mins (subtract 20) time

----------------------------------------------

-- Exercises - Self-Correcting Lenses

data ProducePrices =
  ProducePrices
    { _limePrice  :: Float
    , _lemonPrice :: Float
    }
  deriving (Show)

-- Prices always positive.
-- Prices of limes and lemons must NEVER be further than 50 cents apart.
limePrice :: Lens' ProducePrices Float
limePrice = lens getter setter
  where
    getter (ProducePrices price _) = price
    setter (ProducePrices _ lemonPrice) newPrice =
      let newLimePrice = (max 0 newPrice)
          newLemonPrice =
            clamp (newLimePrice - 0.5) (newLimePrice + 0.5) lemonPrice
       in ProducePrices newLimePrice newLemonPrice
-- >>> let prices = ProducePrices 1.50 1.48
-- >>> set limePrice 2 prices
-- ProducePrices {_limePrice = 2.0, _lemonPrice = 1.5}
-- >>> set limePrice (-1.00) prices
-- ProducePrices {_limePrice = 0.0, _lemonPrice = 0.5}
